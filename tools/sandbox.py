import tempfile
import subprocess
import sys
import os
import re

def detect_ptrac_mode(ptrac_path):
    """
    Automatically detect the format of a PTRAC file.
    Returns:
      - 'BIN_PTRAC' if the file is binary (classic MCNP format).
      - 'ASC_PTRAC' if the file is ASCII (or extended ASCII).
    Detection is based on the header content (presence of readable text).
    """
    try:
        with open(ptrac_path, "rb") as f:
            head = f.read(256)
            if b'ptrac' in head.lower() or all(32 <= b <= 126 or b in b'\r\n\t' for b in head):
                return 'ASC_PTRAC'
            else:
                return 'BIN_PTRAC'
    except Exception:
        return 'BIN_PTRAC'


def patch_ptrac_instantiation(code: str, ptrac_path: str, mode: str) -> str:
    """
    Patch all instances of Ptrac instantiation in the given code.
    - Replaces any form of `Ptrac(...)` with a safe instantiation
      using the correct path and detected mode (ASC_PTRAC or BIN_PTRAC).
    - Works across multiple lines, with varying variable names and indentation.
    Ensures that the correct file path and mode are always used.
    """
    safe_path = ptrac_path.replace("\\", "\\\\")
    ptrac_line = f"Ptrac(r'{safe_path}', Ptrac.{mode})"

    # Replace any generic instantiation of Ptrac(...)
    code_patched = re.sub(
        r"Ptrac\s*\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)",
        ptrac_line,
        code,
        flags=re.MULTILINE
    )

    # Normalize any explicit mode (force to detected one)
    code_patched = re.sub(
        r"Ptrac\.(BIN_PTRAC|ASC_PTRAC|HDF5_PTRAC)", f"Ptrac.{mode}", code_patched
    )

    if code != code_patched:
        print(f"[EVA/SANDBOX] Patch : toutes les instanciations Ptrac forcent le mode détecté : {mode}")

    return code_patched


def patch_plots(code: str, allow_plots: bool, output_file="plot.png") -> str:
    """
    Handle matplotlib plotting:
      - Local (allow_plots=True): flush stdout/stderr just before plt.show().
      - Docker (allow_plots=False): force non-interactive backend and save plots as PNG.
    """
    if allow_plots:
        # Insert flush before plt.show()
        patched = re.sub(
            r"plt\.show\s*\([^\)]*\)",
            "import sys; sys.stdout.flush(); sys.stderr.flush(); plt.show()",
            code
        )
        return patched

    # Docker mode → headless
    header = "import matplotlib\nmatplotlib.use('Agg')\n"
    code = header + code
    # Replace plt.show() with savefig
    code = re.sub(r"plt\.show\s*\([^\)]*\)", f"plt.savefig('{output_file}')", code)
    return code


ACTIVE_PROCESS = None  # Global handle for subprocess management


def run_ptrac_code(code: str, ptrac_path: str, timeout=60, allow_plots=False):
    """
    Execute Python code (generated by OTACON) in a sandboxed environment.
    Steps:
      1. Detect PTRAC file mode (ASCII/Binary).
      2. Patch Ptrac instantiation in the code with safe version.
      3. Handle matplotlib plotting (interactive vs headless).
      4. Write patched code to a temporary directory.
      5. Run code in a subprocess with timeout handling.

    Args:
        code (str): The Python code to execute.
        ptrac_path (str): Path to the PTRAC file.
        timeout (int): Maximum allowed runtime in seconds (default=60).
        allow_plots (bool): If False, replaces plots with PNG export.

    Returns:
        dict: {
            "stdout": Captured standard output,
            "stderr": Captured standard error,
            "exception": None if success, or error type/exit code,
            "output_files": List of generated files (plots, etc.)
        }
    """
    global ACTIVE_PROCESS

    mode = detect_ptrac_mode(ptrac_path)
    patched_code = patch_ptrac_instantiation(code, ptrac_path, mode)
    patched_code = patch_plots(patched_code, allow_plots=allow_plots)

    with tempfile.TemporaryDirectory() as tmpdir:
        code_file = os.path.join(tmpdir, "llm_code.py")
        with open(code_file, "w", encoding="utf-8") as f:
            f.write(patched_code + "\n")

        try:
            ACTIVE_PROCESS = subprocess.Popen(
                [sys.executable, code_file],
                cwd=tmpdir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = ACTIVE_PROCESS.communicate(timeout=timeout)

            exit_code = ACTIVE_PROCESS.returncode if ACTIVE_PROCESS else -1

            result = {
                "stdout": stdout or "",
                "stderr": stderr or "",
                "exception": None if exit_code == 0 else f"Code retour {exit_code}",
                "output_files": []
            }

            # Attach saved plot if generated
            plot_path = os.path.join(tmpdir, "plot.png")
            if os.path.exists(plot_path):
                result["output_files"].append(plot_path)

            return result

        except subprocess.TimeoutExpired:
            if ACTIVE_PROCESS:
                ACTIVE_PROCESS.kill()
            return {
                "stdout": "",
                "stderr": "Timeout: execution too long.",
                "exception": "TimeoutExpired",
                "output_files": []
            }
        except Exception as e:
            return {
                "stdout": "",
                "stderr": str(e),
                "exception": "Exception",
                "output_files": []
            }
        finally:
            ACTIVE_PROCESS = None
