import tempfile
import subprocess
import sys
import os
import re

def detect_ptrac_mode(ptrac_path):
    """
    Automatically detect the format of a PTRAC file.
    Returns:
      - 'BIN_PTRAC' if the file is binary (classic MCNP format).
      - 'ASC_PTRAC' if the file is ASCII (or extended ASCII).
    Detection is based on the header content (presence of readable text).
    """
    try:
        with open(ptrac_path, "rb") as f:
            head = f.read(256)
            if b'ptrac' in head.lower() or all(32 <= b <= 126 or b in b'\r\n\t' for b in head):
                return 'ASC_PTRAC'
            else:
                return 'BIN_PTRAC'
    except Exception:
        return 'BIN_PTRAC'

def patch_ptrac_instantiation(code: str, ptrac_path: str, mode: str) -> str:
    """
    Patch all instances of Ptrac instantiation in the given code.
    - Replaces any form of `Ptrac(...)` with a safe instantiation
      using the correct path and detected mode (ASC_PTRAC or BIN_PTRAC).
    - Works across multiple lines, with varying variable names and indentation.
    Ensures that the correct file path and mode are always used.
    """
    safe_path = ptrac_path.replace("\\", "\\\\")
    ptrac_line = f"Ptrac(r'{safe_path}', Ptrac.{mode})"

    # Replace any generic instantiation of Ptrac(...)
    code_patched = re.sub(
        r"Ptrac\s*\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)",
        ptrac_line,
        code,
        flags=re.MULTILINE
    )

    # Normalize any explicit mode (force to detected one)
    code_patched = re.sub(
        r"Ptrac\.(BIN_PTRAC|ASC_PTRAC|HDF5_PTRAC)", f"Ptrac.{mode}", code_patched
    )

    if code != code_patched:
        print(f"[EVA/SANDBOX] Patch : toutes les instanciations Ptrac forcent le mode détecté : {mode}")

    return code_patched

def patch_disable_plots(code: str) -> str:
    """
    Disable all plotting commands in the code.
    Neutralizes any calls to:
      - plt.show()
      - plt.savefig()
      - plt.ion()
      - fig.show() (or any object.show())
    This prevents runtime blocking or unwanted file generation.
    """
    code = re.sub(r"plt\.show\s*\([^\)]*\)", "# plt.show() désactivé par EVA", code)
    code = re.sub(r"plt\.ion\s*\([^\)]*\)", "# plt.ion() désactivé par EVA", code)
    code = re.sub(r"plt\.savefig\s*\([^\)]*\)", "# plt.savefig() désactivé par EVA", code)
    code = re.sub(r"\.show\s*\([^\)]*\)", "# .show() désactivé par EVA", code)  # pour fig.show()
    return code

ACTIVE_PROCESS = None  # Global handle for subprocess management

def run_ptrac_code(code: str, ptrac_path: str, timeout=60, allow_plots=False):
    """
    Execute Python code (generated by OTACON) in a sandboxed environment.
    Steps:
      1. Detect PTRAC file mode (ASCII/Binary).
      2. Patch Ptrac instantiation in the code with safe version.
      3. Optionally disable plotting (plt.show, savefig, etc.).
      4. Write patched code to a temporary directory.
      5. Run code in a subprocess with timeout handling.

    Args:
        code (str): The Python code to execute.
        ptrac_path (str): Path to the PTRAC file.
        timeout (int): Maximum allowed runtime in seconds (default=60).
        allow_plots (bool): If False, disables matplotlib plotting commands.

    Returns:
        dict: {
            "stdout": Captured standard output,
            "stderr": Captured standard error,
            "exception": None if success, or error type/exit code,
            "output_files": List of generated files (empty for now)
        }
    """
    global ACTIVE_PROCESS

    mode = detect_ptrac_mode(ptrac_path)
    patched_code = patch_ptrac_instantiation(code, ptrac_path, mode)

    if not allow_plots:
        patched_code = patch_disable_plots(patched_code)

    with tempfile.TemporaryDirectory() as tmpdir:
        code_file = os.path.join(tmpdir, "llm_code.py")
        with open(code_file, "w", encoding="utf-8") as f:
            f.write(patched_code + "\n")

        try:
            ACTIVE_PROCESS = subprocess.Popen(
                [sys.executable, code_file],
                cwd=tmpdir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = ACTIVE_PROCESS.communicate(timeout=timeout)

            exit_code = ACTIVE_PROCESS.returncode if ACTIVE_PROCESS else -1

            return {
                "stdout": stdout or "",
                "stderr": stderr or "",
                "exception": None if exit_code == 0 else f"Code retour {exit_code}",
                "output_files": []
            }
        except subprocess.TimeoutExpired:
            if ACTIVE_PROCESS:
                ACTIVE_PROCESS.kill()
            return {
                "stdout": "",
                "stderr": "Timeout: exécution trop longue.",
                "exception": "TimeoutExpired",
                "output_files": []
            }
        except Exception as e:
            return {
                "stdout": "",
                "stderr": str(e),
                "exception": "Exception",
                "output_files": []
            }
        finally:
            ACTIVE_PROCESS = None

