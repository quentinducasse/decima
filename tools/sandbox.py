import tempfile
import subprocess
import sys
import os
import re
import time   # ✅ needed for unique filenames with timestamp

# === Persistent directory for plots in Docker ===
# By default, plots were saved inside a TemporaryDirectory (deleted at the end of execution).
# This prevented the frontend from accessing the file via /download_file.
# We now use a persistent folder "uploads/plots" so that Flask can serve the image.
PLOTS_DIR = os.path.join(os.getcwd(), "uploads", "plots")
os.makedirs(PLOTS_DIR, exist_ok=True)


def detect_ptrac_mode(ptrac_path):
    """
    Automatically detect the format of a PTRAC file.
    Returns:
      - 'BIN_PTRAC' if the file is binary (classic MCNP format).
      - 'ASC_PTRAC' if the file is ASCII (or extended ASCII).
    """
    try:
        with open(ptrac_path, "rb") as f:
            head = f.read(256)
            if b'ptrac' in head.lower() or all(32 <= b <= 126 or b in b'\r\n\t' for b in head):
                return 'ASC_PTRAC'
            else:
                return 'BIN_PTRAC'
    except Exception:
        return 'BIN_PTRAC'


def patch_ptrac_instantiation(code: str, ptrac_path: str, mode: str) -> str:
    """
    Patch all instances of Ptrac instantiation in the given code.
    Ensures the correct file path and detected mode are always used.
    """
    safe_path = ptrac_path.replace("\\", "\\\\")
    ptrac_line = f"Ptrac(r'{safe_path}', Ptrac.{mode})"

    code_patched = re.sub(
        r"Ptrac\s*\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)",
        ptrac_line,
        code,
        flags=re.MULTILINE
    )
    code_patched = re.sub(
        r"Ptrac\.(BIN_PTRAC|ASC_PTRAC|HDF5_PTRAC)", f"Ptrac.{mode}", code_patched
    )

    if code != code_patched:
        print(f"[EVA/SANDBOX] Patch : Ptrac instantiations forced to mode {mode}")

    return code_patched


def patch_plots(code: str, allow_plots: bool, output_file="plot.png") -> str:
    """
    Handle matplotlib plotting:
      - Local (allow_plots=True): keep plt.show().
      - Docker (allow_plots=False): use Agg backend and save plots to persistent path.
    """
    if allow_plots:
        patched = re.sub(
            r"plt\.show\s*\([^\)]*\)",
            "import sys; sys.stdout.flush(); sys.stderr.flush(); plt.show()",
            code
        )
        return patched

    # Docker mode → force non-interactive backend
    header = "import matplotlib\nmatplotlib.use('Agg')\n"
    code = header + code

    # Save figure in persistent location
    output_path = os.path.join(PLOTS_DIR, output_file)

    # ✅ sécuriser le chemin pour éviter les \U, \n... (Windows)
    safe_output_path = output_path.replace("\\", "\\\\")

    code = re.sub(
        r"plt\.show\s*\([^\)]*\)",
        f"plt.savefig(r'{safe_output_path}')",
        code
    )
    return code


ACTIVE_PROCESS = None  # Global handle for subprocess management


def run_ptrac_code(code: str, ptrac_path: str, timeout=600, allow_plots=False):
    """
    Execute Python code (generated by OTACON) in a sandboxed environment.
    Steps:
      1. Detect PTRAC file mode (ASCII/Binary).
      2. Patch Ptrac instantiation.
      3. Handle matplotlib plotting (interactive vs headless).
      4. Run code in a subprocess with timeout handling.
      5. Collect results (stdout, stderr, plots).
    """
    global ACTIVE_PROCESS

    mode = detect_ptrac_mode(ptrac_path)
    patched_code = patch_ptrac_instantiation(code, ptrac_path, mode)

    # Use unique filename for each plot (avoid browser caching old images)
    unique_filename = f"plot_{int(time.time()*1000)}.png"
    patched_code = patch_plots(patched_code, allow_plots=allow_plots, output_file=unique_filename)

    with tempfile.TemporaryDirectory() as tmpdir:
        code_file = os.path.join(tmpdir, "llm_code.py")
        with open(code_file, "w", encoding="utf-8") as f:
            f.write(patched_code + "\n")

        try:
            # === Clean old plots to keep only the last 10 ===
            all_plots = sorted(
                [f for f in os.listdir(PLOTS_DIR) if f.startswith("plot_")],
                key=lambda x: os.path.getmtime(os.path.join(PLOTS_DIR, x))
            )
            if len(all_plots) > 10:
                for old_file in all_plots[:-10]:
                    try:
                        os.remove(os.path.join(PLOTS_DIR, old_file))
                    except Exception:
                        pass

            ACTIVE_PROCESS = subprocess.Popen(
                [sys.executable, code_file],
                cwd=tmpdir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = ACTIVE_PROCESS.communicate(timeout=timeout)
            exit_code = ACTIVE_PROCESS.returncode if ACTIVE_PROCESS else -1

            result = {
                "stdout": stdout or "",
                "stderr": stderr or "",
                "exception": None if exit_code == 0 else f"Exit code {exit_code}",
                "output_files": []
            }

            # Attach saved plot if generated
            plot_path = os.path.join(PLOTS_DIR, unique_filename)
            if os.path.exists(plot_path):
                result["output_files"].append(plot_path)

            return result

        except subprocess.TimeoutExpired:
            if ACTIVE_PROCESS:
                ACTIVE_PROCESS.kill()
            return {
                "stdout": "",
                "stderr": "Timeout: execution too long.",
                "exception": "TimeoutExpired",
                "output_files": []
            }
        except Exception as e:
            return {
                "stdout": "",
                "stderr": str(e),
                "exception": "Exception",
                "output_files": []
            }
        finally:
            ACTIVE_PROCESS = None
